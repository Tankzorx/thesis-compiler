%{
   open Zorx.Frontend.AST
%}

%start start
%token <int> INT
%token <string> NAME
%token MODULE INPORT OUTPORT REG FSM DATAPATH
%token LCP RCP LP RP LSP RSP EOF COMMA COLON SEMICOLON DASH ASSIGN
%token NEQ EQ LEQ GEQ LT GT
%token AND OR
%token PLUS MINUS
%token TRUE FALSE IF

%left NEQ EQ LEQ GEQ LT GT
%left AND OR
%left PLUS MINUS

%type <Program> start
%type <Module list> ModList ModuleL


%%

start: Program EOF          { P($1) }

Program:
    | ModuleL            { $1 }

ModuleL:
    |                       { [] }
    | ModList               { $1 }

ModList:
    | Module                { [$1] }
    | Module ModList        { $1 :: $2}

Module:
    // | MODULE NAME LCP DecL SEMICOLON StmtL RCP     { M($4, $6, []) }
    | MODULE NAME LCP Datapath Fsm RCP     { M($2, $5, $4) }

DecL:
    |                               { [] }
    | DecList                       { $1 }

DecList:
    | Dec                           { [$1] }
    | Dec COMMA DecList             { $1 :: $3}

StmtL:
    |                               { [] }
    | StmtList                      { $1 }

StmtList:
    | Stmt                          { [$1] }
    | Stmt SEMICOLON                { [$1] } // Allow semicolon for single stmts.
    | Stmt SEMICOLON StmtList       { $1 :: $3 }


Stmt:
    | NAME ASSIGN Expr               { Ass($1, $3) }

Access:
    | NAME                           { AVar($1) } 

Expr:
    | Access                         { Access($1) }
    | LP Expr RP                     { $2 }
    | TRUE                           { B(true) }
    | FALSE                          { B(false) }
    | INT                            { N($1) }
    | Expr NEQ Expr                  { BExp($1,Neq,$3) }
    | Expr AND Expr                  { BExp($1,And,$3) }
    | Expr OR Expr                   { BExp($1,Or,$3) }
    | Expr LT Expr                   { BExp($1,Lt,$3) }
    | Expr GT Expr                   { BExp($1,Gt,$3) }
    | Expr EQ Expr                   { BExp($1,Eq,$3) }
    | Expr PLUS Expr                 { BExp($1,Plus,$3) }
    | Expr MINUS Expr                { BExp($1,Minus,$3) }

Fsm:
    // | FSM LCP TransitionL RCP            { Fsm([], $3) }
    | FSM LCP DecL SEMICOLON TransitionL RCP       { Fsm($3, $5) }

ActionL:
    |                               { [] }
    | ActionList                    { $1 }

ActionList:
    | Action                        { [$1] }
    | Action COMMA ActionList       { $1 :: $3 }

Action:
    | NAME LCP StmtL RCP             { printfn "Parsed Action"; Action($1, $3) }
    
Datapath:
    | DATAPATH LCP DecL SEMICOLON ActionL RCP      { Datapath($3, $5)}

TransitionL:
    |                                     { [] }
    | TransitionList                      { $1 }

TransitionList:
    | Transition                          { [$1] }
    | Transition COMMA TransitionList     { $1 :: $3 }

Transition:
    | NAME LSP Expr RSP LP ActionNameList RP GT NAME { T($1, $3, $6, $9) }

ActionNameL:
    |                               { [] }
    | ActionNameList                { $1 }

ActionNameList:
    | NAME                          { [$1] }     
    | NAME COMMA ActionNameList     {  $1 :: $3 }

Dec:
    | NAME COLON Typ                { RegDec($1, $3)}

Typ:
    | INPORT                     { InPort }
    | OUTPORT                    { OutPort }
    | REG                        { Reg }
